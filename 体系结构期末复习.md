# 体系结构期末复习

## 计算机系统结构基础

* 性能
  * MIPS（Million Instructions per Second）：每秒百万条指令
  * MFLOPS（Million Floating-point Operations per Second）：每秒百万个浮点操作
  * 性能唯一指标：执行程序的CPUTime
* 成本
  * $芯片成本=\frac{晶片成本+测试成本+封装成本}{最终成品率}$
  * $晶片成本=\frac{晶圆成本}{每片晶圆的晶片数\times晶片成品率}$
  * $每个晶圆的晶片数=\frac{晶圆面积}{晶片面积}-\frac{晶圆周长}{(2\times晶片面积)^{\frac12}}$ （后一项的分母实际上是在求晶片对角线长度）
  * $晶片成本率=(1+\frac{单位面积内的缺陷数目\times 晶片面积}{a})^{-a}$，a=4
* 功耗
  * 静态功耗和动态功耗与电压的关系
  * 动态功耗$P_{dynamic}=(P_{switch}+P_{short})\propto f_{clk}$，考虑使用总功耗减去静态功耗求解
    * 翻转功耗：$P_{switch}=\frac{C_{out}V_{dd}^2f_{clk}}2$，一般$f_{clk}\propto V_{dd}$，因此$P_{switch}\propto V_{dd}^3$
    * 短路功耗（NMOS和PMOS同时打开导致的短路电流）：$P_{short}$（暂时没有求解公式）
  * 静态功耗：漏电电流在电阻上发热导致，与温度呈指数相关，$P_{leakage}=\frac{U^2}R=\frac{U^2}{U_{static}/I_{static}}$（注意不能用UI，因为I不全在电阻上产生焦耳热）
  * 总功耗$P_{total}=P_{dynamic}+P_{leakage}=UI$

## 二进制与逻辑电路

* 数的表示

  * 定点数补码原码、浮点数
    * 有符号、无符号、浮点转换：
      * 单精度指数偏移127，双精度指数偏移1023
      * 单精度1、8、23位，双精度，1、11、52位
      * 指数为0时是0.几，偏移126或1022。指数为255或2047时无穷
    * 原码+0和-0：+0最高位为0，-0最高位为1
* 画门级电路图
* 延迟计算：

  * 触发器延迟计算（复杂）
    * $T_{setup}$：时钟下降前源必须保持的时间，使得第一级Latch已经采集到
      * $信号源到反馈环路的时间-时钟最早截断源和反馈环路的最后一个逻辑的时间$
    * $T_{hold}$：时钟下降后源依然要保持的时间，使得源的变化恰好无法传递到第一级Latch
      * $时钟最晚截断源和反馈环路的最后一个逻辑的时间-信号源第一次到反馈环路的时间$
    * $T_{cq}：$时钟下降到Q变化的时间
      * $时钟最晚开启两个反馈环路间所有逻辑的时间+信号从第一个反馈环路传递到输出端最短时间$
  * 组合电路延迟计算（简单）
    * $总延迟=\sum_{电路层级i}{TPhl_i}+Thlf_i\times(\sum_{每个输出}(Cil_{i+1}+C_{wire}))$，其中$TPhl$为输出高到低本身延迟，$Thlf$为输出高到低单位负载延迟，$Cil$为输入负载（最后一层为$Col$），$C_{wire}$为连线负载（最后一层不存在连线负载）
* verilog基本的表达式
  
## 指令系统结构

* LL-SC写原子操作和锁
  * ll指令读取临界区数据，同时设置llbit
  * 对数据进行操作
  * sc指令尝试写回临界区，并将写入的结果（llbit）返回寄存器
  * 分支指令判断，若不成功（llbit被修改）则原子性被破坏，则返回ll重新执行


* 基本概念
  * RISC和CISC核心区别：RISC简化了指令间的关系、指令功能和指令编码
  * 小尾端：右边的数在字中的最低地址


## 静态流水线

* 五级流水线的时空图，阻塞情况
* 延迟槽的概念：循环展开看清楚有没有延迟槽
  * 延迟槽：分支指令后一条指令不论分支指令是否跳转成功都要执行


## 动态调度流水线

* 软件循环展开
* 保留站有序变乱序、ROB把乱序变回有序、RENAMEREGFILE暂存结果
  * 保留站：指令在其中等待操作数就绪（解决RAW相关）
  * ROB：记录程序序，实现精确中断
  * 重命名寄存器：将逻辑寄存器动态映射到物理寄存器，临时存数据（解决WAW和WAR相关）
* Tomasulo算法
  * 使用重命名寄存器消除WAW和WAR，RAW使用保留站解决，只有指令的操作数都就绪才会发射
  * 给一张CPU图，IQ里放几条指令，画出每个拍各个保留站、寄存器、ROB的状态
  

## 多发射数据通路

* 保留站组织
  * 全局保留站
  * 分布保留站
  * 每一个FU一个保留站
* 寄存器与保留站的关系
  * 寄存器在前
  * 寄存器在后，少了两次数据拷贝，省功耗
* 重命名寄存器方法
  * 统一物理寄存器，省功耗
  * 保留站中重命名
* 多发射的硬件复杂度与发射数的平方成正比

## 转移预测

* 给一个程序，写循环展开和软流水，算一共多少拍
  * 软件流水：
    
    * 无停顿流水的条件：按照RAW依赖关系分层后，第i层只依赖第i-1层的指令
    
    * 修改方法
    
      * 去掉代码中的循环分支跳转和循环计数器指令，按照依赖关系分层重排代码。
    
        设还剩k列，竖着按顺序写其他指令（注意不同循环基于计数器寄存器的指令的偏移量要递增或递减），接着下一列向下错一条指令写其他指令，一共写k列
    
      * 装入代码：循环体行上面的部分，从上到下、从左到右写，最后基于这些代码跨越循环数补上递增计数器（必须注意是否把计数器递增指令放到延迟槽里，如果是的话，计数器要额外再跨越一个循环）
    
      * 循环体：取中间恰好宽度为k的那一行，作为循环体的前三条指令，最后补上分支和计数器指令。
    
      * 排空代码：循环体行下面的部分，从上到下、从左到右写（注意装入代码里的计数器延迟槽问题）
  
* 基于历史和两位饱和计数器的两层分支预测
  * 历史索引PHT行，PC索引PHT列，注意可能存在哈希
  
* 给一个转移预测器的结构，给一个程序，演算转移预测器的状态和预测结果

* 转移的重复性和相关性的概念
  * 重复性：刚刚执行过的转移指令有可能马上再次被执行，其行为有规律
  * 相关性：不同转移指令之间可能存在依赖关系或逻辑相关性


## 功能部件

* 先行进位加法器：结构和延迟（注意与非、与或、非有一级延迟，与、或有两级延迟）

  ```verilog
  module Carry4(
    input [3:0] p, g,
    input cin,
    output P, G,
    output [3:0] cout
  );
    assign P = &p;
    // 3, 32, 321, 3210, 最后一个是g，前面是p
    assign G = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]);
    assign cout[0] = cin;
    assign cout[1] = g[0] | p[0] & cout[0];
    assign cout[2] = g[1] | p[1] & cout[1];
    assign cout[3] = g[2] | p[2] & cout[2];
  endmodule
  module BLevel_Adder32(
    input [15:0] a, b,
    input cin,
    output [15:0] s,
    output cout
  );
    wire [15:0] p, g;
    assign p = a | b;
    assign g = a & b;
    wire [3:0] P, G, _c;
    wire [15:0] c;
    Carry4 C1(p[3:0], g[3:0], cin, P[0], G[0], c[3:0]); 
    Carry4 C2(p[7:4], g[7:4], _c[1], P[1], G[1], c[7:4]);
    Carry4 C3(p[11:8], g[11:8], _c[2], P[2], G[2], c[11:8]);
    Carry4 C4(p[15:12], g[15:12], _c[3], P[3], G[3], c[15:12]);
    Carry4 C5(.p(P), .g(G), .cin(cin), .P(), .G(), .cout(_c));
    assign s = (~a & ~b & c) | (~a & b & ~c) | (a & ~b & ~c) | (a & b & c);
    assign cout = (a[15] & b[15]) | (a[15] & c[15]) | (b[15] & c[15]);
  endmodule
  ```

  * 结构规律：除了最右侧之外，其余所有的进位都来自于紧邻右侧上一级的输出（也可以是更上一级）

* 2位Booth乘法器：结构和延迟

* verilog写加法器和乘法器，只能用与门或门或非门算延迟，作业题改数

## 高速缓存

* 平均cache访问延迟（AMAT），多级cache
  * 告诉你访问2级cache20拍，那失效惩罚是19拍（而不是20拍）
  * AMAT=访存指令的CPI
* cache结构，告诉cache块大小，相联度，总容量，算index、offset、tag
  * index：表示Cache的组数所用的位宽
  * offset：表示一组多少字节所用的位宽
  * tag：总地址宽度-index-offset

* TLB引起的操作系统页着色算法
  * tag部分超出一页部分的虚拟地址，是多少就映射到那些这些位数和虚拟地址相同的物理地址
  * 计算页着色的位数：tag部分超出一页部分的虚拟地址位数

## 存储管理

* 写一个程序，分析出现多少次例外
  * 缺页先触发TLBrefill，但数据不在内存中，返回后再触发TLBinvalid。
  * 被初始化过一次的页再次TLBrefill，如果数据没有被换出内存，就不会再触发TLBinvalid。
  * 一个TLB表项连续映射两个虚页，因此TLBrefill可能一次填回两个未初始化页，导致遍历访问时触发两次TLBinvalid
  

## 多处理器

* cache一致性协议
  * ESI三个状态的例子，会写状态变化表
    * ESI：E独占（I在写无效时转换到此），S共享（I在读无效时转换到此），I无效
    * MSI：M修改（写时转换到此）
    * MESI：E独占（读取若不在其他核中，则转换到此，写不再需要广播）
  * 目录协议：cache状态和目录状态的演化
    * 位向量：记录了哪里保存了该副本
    * 修改位：一个处理器请求另一个处理器写过的内容时修改为CLEAN，写的时候修改为DIRTY
